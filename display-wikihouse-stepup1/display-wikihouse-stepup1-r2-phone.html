<!doctype html>
<html lang=en >
<head>
<title>WikiHouse Step Up 2.1</title>
<meta charset=utf-8 />
<meta name=viewport content='width=device-width,user-scalable=no,minimum-scale=1.0,maximum-scale=1.0' />
</head>
<body>
<!--
<script src=https://mrdoob.github.io/three.js/build/three.min.js ></script>
<script src=https://mrdoob.github.io/three.js/examples/js/controls/OrbitControls.js ></script>
<script src=https://mrdoob.github.io/three.js/examples/js/libs/stats.min.js ></script>
-->
<script src=https://rawgit.com/mrdoob/three.js/r80/build/three.min.js ></script>
<script src=https://rawgit.com/mrdoob/three.js/r80/examples/js/controls/OrbitControls.js ></script>
<script src=https://rawgit.com/mrdoob/three.js/r80/examples/js/libs/tween.min.js ></script>
<script>

	var fileName = 'StepUp_1_r12.dxf';
	var xmlHttp;

	var components = [];

	var raycaster;
	var mouse;

	var info, stats, renderer, scene, camera, controls;
	var geometry, material, mesh;

	init();
	animate();

	function init() {

		var css = document.head.appendChild( document.createElement('style') );
		css.innerHTML ='body { font: 600 12pt monospace; margin: 0; overflow: hidden; }' +
			'#i {text-decoration: none; }' +
			'button, input[type=button] { background-color: #ccc; border: 2px #fff solid; color: #322; }' +
			'input[type=range] { -webkit-appearance: none; -moz-appearance: none; background-color: #ddd; width: 160px; }' +
			'input[type=range]::-moz-range-thumb { background-color: #888; border-radius: 0; width: 10px; }' +
			'input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; background-color: #888; height: 20px; width: 10px; }' +

		'';

		var info = document.body.appendChild( document.createElement( 'div' ) );
		info.style.cssText = ' margin: 0 10px; max-width: 300px; position: absolute; ';
		info.innerHTML = '<h3 style=margin:0; ><a href="" >' + document.title + '</a> - ' +
			'<a id=i href=http://wikihouse.github.io/viewer-experiments/display-wikihouse-stepup1/ >🛈</a>' +
			'</h3>' +
			'<div><small>Touch any component</small></div>' +
			'<div><button onclick=returnAllToStartTween(); >Return all to start</button> ' +
			'<button onclick=assembleQuicklyTween(); >Assemble Quickly</button></div>' +
			'<div id=msg1 ></div>' +
		'';
/*
// Heads Up
		headsUp = document.body.appendChild( document.createElement( 'div' ) );
		headsUp.style.cssText = 'background-color: #ddd; border-radius: 8px; padding: 0 5px 10px 5px; opacity: 0.85; ' +
			'position: absolute; left: 50px; text-align: left; z-index: 10;';
*/
		container = document.body.appendChild( document.createElement( 'div' ) );
		renderer = new THREE.WebGLRenderer( { alpha: 1, antialias: true, clearColor: 0xffffff }  );
		renderer.setSize( window.innerWidth, window.innerHeight );
		container.appendChild( renderer.domElement );

		camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 15000 );
		camera.position.set( -100, 100, 100 );

		controls = new THREE.OrbitControls( camera, renderer.domElement );

		scene = new THREE.Scene();

// axes
		var axisHelper = new THREE.AxisHelper( 50 );
		scene.add( axisHelper );

		particleMaterial = new THREE.SpriteMaterial( {

			color: 0xff0000,

		} );

		raycaster = new THREE.Raycaster();
		mouse = new THREE.Vector2();

		renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
		renderer.domElement.addEventListener( 'touchstart', onDocumentTouchStart, false ); // for mobile

		requestFile( fileName );

		window.addEventListener( 'resize', onWindowResize, false );

	}

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

		controls.handleResize();

	}



	function requestFile( fileName ) {

		xmlHttp = new XMLHttpRequest();
		xmlHttp.open( 'GET', fileName, true );
		xmlHttp.onreadystatechange = getDXF;
		xmlHttp.send( null );

	}

	var polylines = [];
	var polyline = [];
	var count = -1;

	function getDXF() {

		if ( xmlHttp.readyState !== 4  ) { return; }

		text = xmlHttp.responseText;
		var lines = text.split(/\r\n|\n/);


		for ( var i = 0; i < lines.length; i++ ) {

			var l = lines[ i ];

			if ( l === 'POLYLINE' ) {

				polylines[ ++count ] = [];

			} else if ( l === 'VERTEX' ) {

				polylines[ count ].push( v2( + lines[ i + 10] , + lines[ i + 12 ] ) ); // +  sign forces string to number

			}

		}

//console.log( polylines );

		for ( var i = 0; i < polylines.length; i++ ) {

//			drawPolygon( i, 0 );

		}

//		startRotation = endRotation = v( 0, 0, 0 );

		holes = [ 0, 1, 2, 3, 4, 8, 32, 33 ]

		drawPolygon( 24, holes, v( 0, 0, 0 ), v( 53.5, 23.31, 60 ), v( 0, 0, 0 ), v( 0, 0, 0 ) );

		holes = [ 34, 35, 36, 37 ];

		drawPolygon( 25, holes, v( 0, 0, 0 ), v( -7, 100, 33.5 ), v( 0, 0, 0 ), v( -0.5 * Math.PI, 0, 0 ) );

		holes = [ 10, 11, 12, 13, 14, 40, 41 ];

		drawPolygon( 26, holes, v( 0, 0, 0 ), v( 32.51, -1, -31 ), v( 0, 0, 0 ), v( Math.PI, 0, 0 ) );

		holes = [ 38, 39 ];

		drawPolygon( 27, holes, v( 0, 0, 0 ), v( 54, 75.5, -7 ), v( 0, 0, 0 ), v( 0.5 * Math.PI, Math.PI, 0.5 * Math.PI ) );

		holes = [ 43 ];

		drawPolygon( 28, holes, v( 0, 0, 0 ), v( -1, -56.25, 32.75 ), v( 0, 0, 0 ), v( Math.PI, -0.5 * Math.PI, 0 ) );

		holes = [ 42 ];

		drawPolygon( 29, holes, v( 0, 0, 0 ), v( 55.95, 53.51, 115.36 ), v( 0, 0, 0 ), v( 0.5 * Math.PI, 0.5 * Math.PI, 0 ) );

		drawPolygon( 30, 0, v( 0, 0, 0 ), v( -57.5, 77.5, 61 ), v( 0, 0, 0 ), v( -0.5 * Math.PI, 0, 0.5 * Math.PI ) );

		drawPolygon( 31, 0, v( 0, 0, 0 ), v( -57.5, 97.5, 72 ), v( 0, 0, 0 ), v( -0.5 * Math.PI, 0, 0.5 * Math.PI ) );

		drawPolygon( 18, 0, v( 0, 0, 0 ), v( -4, 122, 60 ), v( 0, 0, 0 ), v( 0, 0, 0 ) );

		drawPolygon( 21, 0, v( 0, 0, 0 ), v( 11, 122, 60 ), v( 0, 0, 0 ), v( 0, 0, 0 ) );

		drawPolygon( 17, 0, v( 0, 0, 0 ), v( -4, 127, 67 ), v( 0, 0, 0 ), v( 0, 0, 0 ) );

		drawPolygon( 20, 0, v( 0, 0, 0 ), v( 11, 127, 67 ), v( 0, 0, 0 ), v( 0, 0, 0 ) );

		drawPolygon( 5, 0, v( 0, 0, 0 ), v( 56, 87, -22 ), v( 0, 0, 0 ), v( -0.5 * Math.PI, 0, 0 ) );

		drawPolygon( 6, 0, v( 0, 0, 0 ), v( 0, -11.5, -30 ), v( 0, 0, 0 ), v( -0.5 * Math.PI, Math.PI, 0 ) );

		polys = [ 7, 9, 16, 19 ];

		for ( var i = 0; i < polys.length; i++ ) {

			drawPolygon( polys[ i ], 0, v( 0, 0, 0 ), v( 0, 0, 50 ), v( 0, 0, 0 ), v( 0, 0, 0 ) );

		}

	}



	function drawPolygon( id, holes, startPosition, endPosition, startRotation, endRotation ) {

		vertices = polylines[ id ];

		if ( vertices.length < 3 ) {

console.log( 'oops col ', id );

			return;

		}

		shape = new THREE.Shape();
		shape.fromPoints( vertices );

		for ( var i = 0; i < holes.length; i++ ) {

			var holePath = new THREE.Path();
			holePath.fromPoints( polylines[ holes[ i ] ].reverse() );
			shape.holes.push( holePath );

		}

		thickness = vertices.length >  12 || id === 25 ? 20 : 30;
		thickness = 18;

        var extrudeSettings = {
        	steps: 2,
        	amount: thickness,
        	bevelEnabled: false,
        	bevelThickness: 1,
        	bevelSize: 1,
        	bevelSegments: 1
        };

        var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );

		geometry.applyMatrix( new THREE.Matrix4().makeTranslation( -39600, -28200, -500 ) );

		gruntWork( geometry, id, startPosition, endPosition, startRotation, endRotation  )

	}



	function gruntWork( geometry, id, startPosition, endPosition, startRotation, endRotation  ) {

		material = new THREE.MeshNormalMaterial( { wireframe: false } );
		mesh = new THREE.Mesh( geometry, material );
//		mesh.position.set( 0, y, 3 * z  );
		mesh.scale.multiplyScalar( 0.1 );

		mesh.userData.startPosition = startPosition;
		mesh.userData.endPosition = endPosition;

		mesh.userData.startRotation = startRotation;
		mesh.userData.endRotation = endRotation;

		mesh.userData.index = id;
		components.push( mesh );
		scene.add( mesh );

		edgesGeometry = new THREE.EdgesGeometry( geometry ); // or WireframeGeometry
		edgesMaterial = new THREE.LineBasicMaterial( { color: 0x000000, linewidth: 5 } );
		edges = new THREE.LineSegments( edgesGeometry, edgesMaterial );
		mesh.add( edges ); // add wireframe as a child of the parent mesh

	}



	function onDocumentTouchStart( event ) {

		event.preventDefault();

		event.clientX = event.touches[0].clientX;
		event.clientY = event.touches[0].clientY;
		onDocumentMouseDown( event );

	}

	function onDocumentMouseDown( event ) {

		event.preventDefault();

		mouse.x = ( event.clientX / renderer.domElement.width ) * 2 - 1;
		mouse.y = - ( event.clientY / renderer.domElement.height ) * 2 + 1;

		raycaster.setFromCamera( mouse, camera );

		var intersects = raycaster.intersectObjects( components );

		if ( intersects.length > 0 ) {

			intersected = intersects[ 0 ].object;

			verts = intersected.geometry.vertices;
			dis = 1000000000;
			ip = intersects[ 0 ].point;

			for ( var i = 0; i < verts.length; i++ ) {

				vert = verts[ i ].clone();
				vert.applyMatrix4( intersected.matrixWorld );
				d = vert.distanceTo( ip );
				if ( d < dis ) {
					dis = d;
					pt = vert;
				}

			}

			var particle = new THREE.Sprite( particleMaterial );

			particle.position.copy( pt );
			particle.scale.x = particle.scale.y = 1;
			scene.add( particle );

//			intersected.material.color.setHex( Math.random() * 0xffffff );

//			headsUp.style.left = 50 + 0.5 * window.innerWidth + mouse.x * 0.5 * window.innerWidth + 'px';
//			headsUp.style.top = -10 + 0.5 * window.innerHeight - mouse.y * 0.5 * window.innerHeight + 'px';
//			headsUp.style.display = '';

			msg1.innerHTML  = // '<h3 style="margin:0;" >Component Data Viewer</h3>' +
				'<small>Three.js id:' + intersected.id + '<br>' +
				'UUID:' + intersected.uuid + '<br>' +
//				'Type: ' + intersected.type + '<br>' +
				'index: ' + intersected.userData.index + '</small>' +
//				'Point x: ' + intersects[ 0 ].point.x.toFixed(2) + ' y:' + intersects[ 0 ].point.y.toFixed(2) + ' z:' + intersects[ 0 ].point.z.toFixed(2) + '<br>' +
//				'vertex x:' + pt.x.toFixed(2) + ' y:' + pt.y.toFixed(2) + ' z:' + pt.z.toFixed(2) + '<br>' +

			'';

			movRotTween( intersected );

		} else {

			intersected = null;

//			headsUp.style.display = 'none';

			document.body.style.cursor = 'auto';

		}

	}

	function movRotTween( obj ) {

		var tween = new TWEEN.Tween( obj.position );
		var oData = obj.userData;

		if ( obj.position.distanceTo( obj.userData.startPosition ) < 1 ) {

			tween.to( {
				x: oData.endPosition.x,
				y: oData.endPosition.y,
				z: oData.endPosition.z }, 2000 )

			tween.easing( TWEEN.Easing.Elastic.Out).start();

			new TWEEN.Tween( obj.rotation ).to( {
				x: oData.endRotation.x,
				y: oData.endRotation.y,
				z: oData.endRotation.z }, 2000 )
			.easing( TWEEN.Easing.Elastic.Out).start();

		} else {

			tween.to( {
				x: oData.startPosition.x,
				y: oData.startPosition.y,
				z: oData.startPosition.z }, 2000 )

			tween.easing( TWEEN.Easing.Elastic.Out).start();

			new TWEEN.Tween( obj.rotation ).to( {
				x: oData.startRotation.x,
				y: oData.startRotation.y,
				z: oData.startRotation.z }, 2000 )
			.easing( TWEEN.Easing.Elastic.Out).start();

		}

	}

	function returnAllToStartTween() {

		for ( var i = 0; i < components.length; i++ ) {

			obj = components[ i ];

			var tween = new TWEEN.Tween( obj.position );
			var oData = obj.userData;

			if ( obj.position.distanceTo( obj.userData.startPosition ) != 0 ) {

				tween.to( {
					x: oData.startPosition.x,
					y: oData.startPosition.y,
					z: oData.startPosition.z }, 2000 )

				tween.easing( TWEEN.Easing.Elastic.Out).start();

				new TWEEN.Tween( obj.rotation ).to( {
					x: oData.startRotation.x,
					y: oData.startRotation.y,
					z: oData.startRotation.z }, 2000 )
				.easing( TWEEN.Easing.Elastic.Out).start();

			}

		}

	}

	function assembleQuicklyTween() {

		for ( var i = 0; i < components.length; i++ ) {

			obj = components[ i ];

			var tween = new TWEEN.Tween( obj.position );
			var oData = obj.userData;

			if ( obj.position.distanceTo( obj.userData.endPosition ) != 0 ) {

				tween.to( {
					x: oData.endPosition.x,
					y: oData.endPosition.y,
					z: oData.endPosition.z }, 2000 )

				tween.easing( TWEEN.Easing.Elastic.Out).start();

				new TWEEN.Tween( obj.rotation ).to( {
					x: oData.endRotation.x,
					y: oData.endRotation.y,
					z: oData.endRotation.z }, 2000 )
				.easing( TWEEN.Easing.Elastic.Out).start();

			}

		}

	}

	function setExplodeStructure() {

		s = 1 + parseFloat( inpStretch.value ) / 100;

		cc = components;

		for ( var i = 0; i < cc.length; i++ ) {
/*
			if ( !cc[ i ].positionStart ) {

				cc[ i ].positionStart = cc[ i ].position.clone();

			}
*/
			p = cc[ i ].userData.startPosition;

			cc[ i ].position.set( s * p.x, s * p.y, s * p.z );

//console.log(  'name', cc[ i ].name );

		}

	}

	function v2( x, y ){ return new THREE.Vector2( x, y ); }
	function v( x, y, z ){ return new THREE.Vector3( x, y, z ); }

	function animate() {

		requestAnimationFrame( animate );
		controls.update();

		TWEEN.update();
		renderer.render( scene, camera );

	}

</script>
</body>
</html>


